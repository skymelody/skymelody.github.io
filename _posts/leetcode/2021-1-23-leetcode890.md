---
layout:     post
title:      1351. 890. Find and Replace Pattern
date:       2020-1-23
author:     skymelody
header-img: img/the-first.png
catalog: false 
tags:
    - leetcode
---
You have a list of `words` and a `pattern`, and you want to know which words in `words` matches the pattern.

A word matches the pattern if there exists a permutation of letters `p` so that after replacing every letter `x` in the pattern with `p(x)`, we get the desired word.

(*Recall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.*)

Return a list of the words in `words` that match the given pattern. 

You may return the answer in any order.



Examples:

```
Input: words = ["abc","deq","mee","aqq","dkd","ccc"], pattern = "abb"
Output: ["mee","aqq"]
Explanation: "mee" matches the pattern because there is a permutation {a -> m, b -> e, ...}. 
"ccc" does not match the pattern because {a -> c, b -> c, ...} is not a permutation,
since a and b map to the same letter.
```

思路：
1. 暴力法

   遍历words中的每一个word， 利用两个unordered_map建立word与pattern的双射关系。如果发现word中的某个字符不满足双射关系中的一一对应，那么就不把它加入到ans中

   ```cpp
   class Solution {
   public:
       vector<string> findAndReplacePattern(vector<string>& words, string pattern) {
           vector<string> ans;
           for (const string& word : words) {
               if (word.size() == pattern.size()) {
                   unordered_map<char, char> mp;
                   unordered_map<char, char> mp1;
                   int n = word.size();
                   bool to_add = true;
                   for (int i = 0; i < n; ++i) {
                       if (mp.count(word[i]) == 0) {
                           if (mp1.count(pattern[i]) == 0) {
                               mp[word[i]] = pattern[i];
                               mp1[pattern[i]] = word[i];
                           }
                           else {
                               to_add = false;
                               break;
                           }
                       }
                       else if (mp[word[i]] != pattern[i]) {
                           to_add = false;
                           break;
                       }
                   }
                   if (to_add) {
                       ans.push_back(word);
                   }
               }
           }
           return ans;
       }
   };
   ```

   