---
layout:     post
title:      1277. Count Square Submatrices with All Ones
date:       2020-10-17
author:     skymelody
header-img: img/the-first.png
catalog: false 
tags:

   - leetcode
---

Given a `m * n` matrix of ones and zeros, return how many **square** submatrices have all ones.

Examples：

```
Input: matrix =
[
  [0,1,1,1],
  [1,1,1,1],
  [0,1,1,1]
]
Output: 15
Explanation: 
There are 10 squares of side 1.
There are 4 squares of side 2.
There is  1 square of side 3.
Total number of squares = 10 + 4 + 1 = 15.
```

思路：

以每个元素为正方形的右下角，统计其按辅对角线长度所能构成正方形的数目。如：

```
0 1 1 0
0 1 1 1
0 0 1 1 
```

以(2， 3)为右下角，其辅对角线（连续的1）最大为3， 但其能构成正方形的最大对角线长度为2。能构成两个正方形：

```
1

1 1
1 1
```



实现：

```cpp
	int countSquares(vector<vector<int>>& matrix) {
  int ans = 0;
  int m = matrix.size();
  int n = matrix[0].size();
  auto row = matrix;
  auto col = matrix;
  auto diag = matrix;
  for (int i = 0; i < m; ++i) {
    for (int j = 0; j < n; ++j) {
      if (matrix[i][j] == 1) {
        if (i-1 >= 0) {
          col[i][j] += col[i-1][j];
        }
        if (j-1 >= 0) {
          row[i][j] += row[i][j-1];
        }
        if (i-1 >= 0 && j-1 >= 0) {
          diag[i][j] += min(diag[i-1][j-1], min(row[i][j-1], col[i-1][j])); 
        }
      }
    }
  }
  for (int i = 0; i < m; ++i) {
    for (int j = 0; j < n; ++j) {
      if (col[i][j] != 0 && row[i][j] != 0 && diag[i][j] != 0) {
        ans += min(row[i][j], min(col[i][j], diag[i][j]));
      }
      else {
        ans += matrix[i][j];
      }
    }
  }
  return ans;
}
```



优化：

```cpp
int countSquares(vector<vector<int>>& matrix) {
  int ans = 0;
  int m = matrix.size();
  int n = matrix[0].size();
  for (int i = 0; i < m; ++i) {
    for (int j = 0; j < n; ++j) {
      if (i-1 >= 0 && j-1 >= 0 && matrix[i][j] != 0) {
        matrix[i][j] += min(matrix[i-1][j-1], min(matrix[i][j-1], matrix[i-1][j]));
      }
      ans += matrix[i][j];
    }
  }
  return ans;
}
```

